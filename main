# -*- coding: utf-8 -*-
"""
高德地图 POI 数据采集工具
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import threading
import math
import json
import time
import os
import queue
import datetime
import requests
import pandas as pd
from shapely.geometry import Polygon, MultiPolygon
import traceback
import sys
import shutil
import subprocess
import platform
from collections import defaultdict

# 默认设置文件位置
DEFAULT_SETTINGS_FILE = os.path.join(os.path.expanduser("~"), "setting.json")

# 核心配置（贴合高德API规范）
REQUEST_INTERVAL = 3.0  # 普通请求间隔（秒）
KEY_SWITCH_DELAY = 6.0  # Key切换后延迟（秒）- 改为6秒
ERROR_DELAY = 5.0  # 异常后延迟（秒）
KEY_COOLDOWN_TIME = 3000  # 临时超限Key冷却时间（秒）
KEY_MAX_USAGE = 8000  # Key最大使用次数限制
FLOAT_EPS = 1e-6  # 浮点数精度容错


# ==============================================================================
# 核心逻辑类
# ==============================================================================

class CoordinateConverter:
    def __init__(self):
        self.x_pi = 3.14159265358979324 * 3000.0 / 180.0
        self.pi = 3.1415926535897932384626
        self.a = 6378245.0
        self.ee = 0.00669342162296594323

    def gcj02_to_wgs84(self, lng, lat):
        if self.out_of_china(lng, lat):
            return [round(lng, 6), round(lat, 6)]
        dlat = self._transformlat(lng - 105.0, lat - 35.0)
        dlng = self._transformlng(lng - 105.0, lat - 35.0)
        radlat = lat / 180.0 * self.pi
        magic = math.sin(radlat)
        magic = 1 - self.ee * magic * magic
        sqrtmagic = math.sqrt(magic)
        dlat = (dlat * 180.0) / ((self.a * (1 - self.ee)) / (magic * sqrtmagic) * self.pi)
        dlng = (dlng * 180.0) / (self.a / sqrtmagic * math.cos(radlat) * self.pi)
        mglat = lat + dlat
        mglng = lng + dlng
        return [round(lng * 2 - mglng, 6), round(lat * 2 - mglat, 6)]

    def out_of_china(self, lng, lat):
        return not (73.66 <= lng <= 135.05 and 3.86 <= lat <= 53.55)

    def _transformlat(self, lng, lat):
        ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + \
              0.1 * lng * lat + 0.2 * math.sqrt(math.fabs(lng))
        ret += (20.0 * math.sin(6.0 * lng * self.pi) + 20.0 * math.sin(2.0 * lng * self.pi)) * 2.0 / 3.0
        ret += (20.0 * math.sin(lat * self.pi) + 40.0 * math.sin(lat / 3.0 * self.pi)) * 2.0 / 3.0
        ret += (160.0 * math.sin(lat / 12.0 * self.pi) + 320 * math.sin(lat * self.pi / 30.0)) * 2.0 / 3.0
        return ret

    def _transformlng(self, lng, lat):
        ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + \
              0.1 * lng * lat + 0.1 * math.sqrt(math.fabs(lng))
        ret += (20.0 * math.sin(6.0 * lng * self.pi) + 20.0 * math.sin(2.0 * lng * self.pi)) * 2.0 / 3.0
        ret += (20.0 * math.sin(lng * self.pi) + 40.0 * math.sin(lng / 3.0 * self.pi)) * 2.0 / 3.0
        ret += (150.0 * math.sin(lng / 12.0 * self.pi) + 300.0 * math.sin(lng / 30.0 * self.pi)) * 2.0 / 3.0
        return ret


class KeyManager:
    def __init__(self, key_list=None, auto_rotate=True):
        self.keys = key_list or []
        self.index = 0
        self.usage_stats = {k: 0 for k in self.keys}
        self.temp_cooldown = dict()  # 临时冷却Key: 冷却结束时间戳
        self.auto_rotate = auto_rotate

    def set_keys(self, key_list):
        self.keys = key_list  # 不再过滤任何Key（去掉永久无效设置）
        self.index = 0
        # 保留原有统计，新key初始化为0
        for k in self.keys:
            if k not in self.usage_stats:
                self.usage_stats[k] = 0
        # 清理冷却中但已被移除的Key
        self.temp_cooldown = {k: t for k, t in self.temp_cooldown.items() if k in self.keys}

    def get_current_key(self):
        """获取当前可用的Key（跳过冷却和达到使用上限的）"""
        if not self.keys:
            return None

        # 先检查当前Key是否可用
        current_key = self.keys[self.index]
        if self._is_key_available(current_key):
            return current_key

        # 遍历所有Key找可用的
        return self.switch_key()

    def switch_key(self):
        """切换到下一个可用的Key（切换后延迟6秒）"""
        if not self.keys:
            return None

        start_index = self.index
        while True:
            self.index = (self.index + 1) % len(self.keys)
            current_key = self.keys[self.index]

            # 找到可用Key或循环一圈后返回（即使不可用也返回，避免死循环）
            if self._is_key_available(current_key) or self.index == start_index:
                # 切换后延迟6秒
                time.sleep(KEY_SWITCH_DELAY)
                return current_key

    def _is_key_available(self, key):
        """检查Key是否可用：未冷却 + 未达使用上限"""
        # 检查是否在冷却中
        if key in self.temp_cooldown:
            if time.time() < self.temp_cooldown[key]:
                return False
            else:
                # 冷却时间到，移除冷却标记，重置使用次数
                del self.temp_cooldown[key]
                self.usage_stats[key] = 0
        # 检查是否达到使用次数上限
        if self.usage_stats.get(key, 0) >= KEY_MAX_USAGE:
            # 达到上限，自动进入冷却
            self.mark_key_cooldown(key)
            return False
        return True

    def mark_key_cooldown(self, key):
        """标记Key进入冷却期"""
        if key in self.keys:
            cool_down_end = time.time() + KEY_COOLDOWN_TIME
            self.temp_cooldown[key] = cool_down_end
            self.log(f"Key {key[:6]}... 达到使用上限({KEY_MAX_USAGE}次)或失效，进入冷却期({KEY_COOLDOWN_TIME}秒)", "WARNING")

    def mark_key_status(self, key, error_info):
        """根据错误信息标记Key状态（只做冷却，不做永久失效）"""
        if not key or key not in self.keys:
            return

        # 任何错误都标记为冷却（去掉永久无效逻辑）
        self.mark_key_cooldown(key)

    def record_usage(self, key, count=1):
        if key in self.usage_stats:
            self.usage_stats[key] += count
            # 检查是否达到使用上限
            if self.usage_stats[key] >= KEY_MAX_USAGE:
                self.mark_key_cooldown(key)

    def get_usage(self):
        return dict(self.usage_stats)

    def get_key_status(self, key):
        """获取Key的状态描述"""
        if key in self.temp_cooldown:
            remaining = int(self.temp_cooldown[key] - time.time())
            usage = self.usage_stats.get(key, 0)
            return f"冷却中({remaining}s) - 已用{usage}/{KEY_MAX_USAGE}次"
        usage = self.usage_stats.get(key, 0)
        return f"正常可用 - 已用{usage}/{KEY_MAX_USAGE}次"

    def log(self, msg, level="INFO"):
        """内部日志（可对接主程序日志队列）"""
        # 实际使用时会通过主程序的log_queue输出
        pass


class AmapCrawlerLogic:
    def __init__(self, log_queue, stop_event, city_boundary_cache=None):
        self.log_queue = log_queue
        self.stop_event = stop_event
        self.converter = CoordinateConverter()
        # 城市边界缓存 {citycode: {'polyline': '', 'bbox': '', 'update_time': ''}}
        self.city_boundary_cache = city_boundary_cache or {}

    def log(self, msg, level="INFO"):
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        self.log_queue.put({"time": timestamp, "msg": msg, "level": level})

    def get_city_coords(self, key_manager, citycode, timeout=15):
        """获取城市边界（优先使用缓存）"""
        # 1. 先检查缓存
        if citycode in self.city_boundary_cache:
            cache_data = self.city_boundary_cache[citycode]
            polyline = cache_data.get('polyline')
            bbox = cache_data.get('bbox')
            update_time = cache_data.get('update_time', '')

            if polyline and bbox:
                self.log(f"使用缓存的城市 {citycode} 边界数据（缓存时间：{update_time}）", "SUCCESS")
                return polyline, bbox
            else:
                self.log(f"城市 {citycode} 缓存数据不完整，重新获取", "WARNING")

        # 2. 缓存未命中或数据不完整，从API获取
        max_attempts = len(key_manager.keys) * 2  # 最大重试次数=Key数量*2
        tried = 0
        last_error = ""

        while tried < max_attempts and not self.stop_event.is_set():
            current_key = key_manager.get_current_key()
            if not current_key:
                self.log("无可用的API Key", "ERROR")
                return None, None

            # 日志显示Key状态
            key_status = key_manager.get_key_status(current_key)
            self.log(f"使用Key {current_key[:6]}... (状态: {key_status}) 获取城市 {citycode} 边界", "INFO")

            url = 'https://restapi.amap.com/v3/config/district'
            params = {'key': current_key, 'keywords': citycode, 'extensions': 'all'}

            try:
                resp = requests.get(url, params=params, timeout=timeout)
                data = resp.json()

                if data.get('status') == '1' and data.get('districts'):
                    polyline = data["districts"][0].get("polyline", "")
                    lons, lats = [], []
                    polygons = polyline.split("|")
                    for poly in polygons:
                        for coord in poly.split(";"):
                            if coord:
                                lon, lat = map(float, coord.split(','))
                                lons.append(lon)
                                lats.append(lat)
                    if not lons:
                        self.log(f"城市 {citycode} 无有效坐标数据", "WARNING")
                        return None, None

                    bbox = f"{min(lons)},{max(lats)}|{max(lons)},{min(lats)}"
                    self.log(f"成功获取城市 {citycode} 边界，矩形范围: {bbox}", "SUCCESS")

                    # 3. 缓存新获取的边界数据
                    self.city_boundary_cache[citycode] = {
                        'polyline': polyline,
                        'bbox': bbox,
                        'update_time': datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }

                    time.sleep(REQUEST_INTERVAL)  # 正常请求后延迟
                    return polyline, bbox
                else:
                    info = data.get('info', '未知错误')
                    last_error = info
                    self.log(f"Key {current_key[:6]}... 请求城市边界失败: {info}", "WARNING")

                    # 标记Key状态并切换
                    key_manager.mark_key_status(current_key, info)
                    current_key = key_manager.switch_key()
                    time.sleep(KEY_SWITCH_DELAY)  # 切换Key后延迟

            except Exception as e:
                last_error = str(e)
                self.log(f"网络请求异常 (get_city_coords): {e}", "ERROR")
                # 切换Key并延迟
                key_manager.switch_key()
                time.sleep(ERROR_DELAY)  # 异常后延迟

            tried += 1

        self.log(f"城市 {citycode} 边界获取失败（已重试{max_attempts}次），最后错误: {last_error}", "ERROR")
        return None, None

    def generate_grids(self, polyline_coords, bbox, grid_size):
        """"""
        if not bbox or not polyline_coords:
            self.log("bbox或城市边界坐标为空，无法生成网格", "WARNING")
            return []

        # ========== 核心修复：正确解析bbox ==========
        try:
            # bbox格式：min_lng,max_lat|max_lng,min_lat（从get_city_coords函数生成）
            part1, part2 = bbox.split('|')
            min_lng_str, max_lat_str = part1.split(',')
            max_lng_str, min_lat_str = part2.split(',')

            # 转换为浮点数
            min_lng = float(min_lng_str)
            max_lng = float(max_lng_str)
            min_lat = float(min_lat_str)
            max_lat = float(max_lat_str)

            # 日志输出解析结果（调试用）
            self.log(f"网格生成参数：min_lng={min_lng:.6f}, max_lng={max_lng:.6f}, "
                     f"min_lat={min_lat:.6f}, max_lat={max_lat:.6f}, grid_size={grid_size}", "INFO")

            # 检查坐标合理性
            if max_lng - min_lng < FLOAT_EPS or max_lat - min_lat < FLOAT_EPS:
                self.log(f"城市边界范围过小（经度跨度：{max_lng - min_lng:.6f}，纬度跨度：{max_lat - min_lat:.6f}）", "WARNING")
                return []

            # 确保min/max正确
            if min_lng > max_lng:
                min_lng, max_lng = max_lng, min_lng
            if min_lat > max_lat:
                min_lat, max_lat = max_lat, min_lat

        except Exception as e:
            self.log(f"解析bbox失败：{e}，bbox格式应为'min_lng,max_lat|max_lng,min_lat'", "ERROR")
            return []

        # ========== 处理城市边界多边形 ==========
        polygons_geo = []
        for poly_str in polyline_coords.split('|'):
            points = []
            for pt in poly_str.split(';'):
                if pt.strip():
                    try:
                        lon, lat = map(float, pt.split(','))
                        points.append((lon, lat))
                    except Exception as e:
                        self.log(f"跳过无效坐标：{pt}（错误：{e}）", "WARNING")
                        continue
            if len(points) >= 3:
                polygons_geo.append(Polygon(points))
            else:
                self.log(f"跳过无效多边形（少于3个点）：{poly_str}", "WARNING")

        if not polygons_geo:
            self.log("未解析到有效城市边界多边形，无法生成网格", "ERROR")
            return []

        admin_geo = MultiPolygon(polygons_geo) if len(polygons_geo) > 1 else polygons_geo[0]

        # ========== 生成网格并筛选相交部分 ==========
        grids = []
        curr_lng = min_lng
        lng_count = 0  # 统计经度方向网格数
        lat_count = 0  # 统计纬度方向网格数

        # 经度循环
        while curr_lng < max_lng + FLOAT_EPS:
            curr_lat = max_lat
            lat_count = 0
            # 纬度循环
            while curr_lat > min_lat - FLOAT_EPS:
                # 计算网格四角坐标
                lng1 = curr_lng
                lng2 = curr_lng + grid_size
                lat1 = curr_lat
                lat2 = curr_lat - grid_size

                # 构建网格多边形
                grid_poly = Polygon([(lng1, lat1), (lng2, lat1), (lng2, lat2), (lng1, lat2)])

                # 筛选与城市边界相交的网格
                if grid_poly.intersects(admin_geo):
                    grids.append(f"{lng1:.6f},{lat1:.6f}|{lng2:.6f},{lat2:.6f}")

                # 纬度步长
                curr_lat = round(curr_lat - grid_size, 6)
                lat_count += 1

            # 经度步长
            curr_lng = round(curr_lng + grid_size, 6)
            lng_count += 1

        # 日志输出网格生成结果
        self.log(f"生成网格统计：经度方向{lng_count}个，纬度方向{lat_count}个，有效相交网格{len(grids)}个", "INFO")

        return grids

    def fetch_pois(self, key_manager, type_code, grid_polygon, timeout=15):
        """获取POI数据"""
        current_key = key_manager.get_current_key()
        if not current_key:
            self.log("无可用的API Key", "ERROR")
            return []

        base_url = 'https://restapi.amap.com/v3/place/polygon'
        all_pois = []

        # 第一步：获取POI总数
        total_count, page_count = self._get_poi_total_count(key_manager, type_code, grid_polygon, timeout)
        if total_count == 0:
            return []
        if total_count == -1:
            self.log("获取POI总数失败，跳过当前网格", "ERROR")
            return []

        self.log(f"当前网格预计有 {total_count} 个POI，共 {page_count} 页", "INFO")

        # 第二步：分页获取POI
        for page in range(1, page_count + 1):
            if self.stop_event.is_set():
                break

            # 检查当前Key是否可用
            if not key_manager._is_key_available(current_key):
                current_key = key_manager.switch_key()
                self.log(f"切换到Key {current_key[:6]}... 继续获取第 {page} 页", "INFO")

            params = {
                'key': current_key,
                'polygon': grid_polygon,
                'types': type_code,
                'offset': 20,
                'page': page,
                'extensions': 'all'
            }

            try:
                self.log(f"正在获取第 {page}/{page_count} 页数据 (Key: {current_key[:6]}...)", "INFO")
                resp = requests.get(base_url, params=params, timeout=timeout)
                data = resp.json()

                if data.get('status') == '0':
                    info = data.get('info', '未知错误')
                    self.log(f"API错误 [{info}] (key {current_key[:6]}...)", "WARNING")

                    # 标记Key状态并切换
                    key_manager.mark_key_status(current_key, info)
                    current_key = key_manager.switch_key()
                    continue

                pois = data.get('pois', [])
                if not pois:
                    self.log(f"第 {page} 页无数据", "INFO")
                    time.sleep(REQUEST_INTERVAL)
                    continue

                # 处理POI数据
                for p in pois:
                    res = {
                        "poi_id": p.get('id'),
                        "name": p.get('name'),
                        "type": p.get('type'),
                        "typecode": p.get('typecode'),
                        "address": p.get('address'),
                        "tel": p.get('tel'),
                        "cityname": p.get('cityname'),
                        "adname": p.get('adname'),
                        "lon_gcj": "",
                        "lat_gcj": "",
                        "lon_wgs": "",
                        "lat_wgs": ""
                    }
                    loc = p.get('location')
                    if loc:
                        try:
                            lon, lat = map(float, loc.split(','))
                            res['lon_gcj'], res['lat_gcj'] = lon, lat
                            w_lon, w_lat = self.converter.gcj02_to_wgs84(lon, lat)
                            res['lon_wgs'], res['lat_wgs'] = w_lon, w_lat
                        except:
                            pass
                    all_pois.append(res)
                    key_manager.record_usage(current_key)

                self.log(f"第 {page} 页获取成功，新增 {len(pois)} 个POI", "SUCCESS")
                time.sleep(REQUEST_INTERVAL)  # 分页请求延迟

            except Exception as e:
                self.log(f"第 {page} 页请求异常：{e}", "ERROR")
                # 切换Key并延迟
                key_manager.mark_key_status(current_key, str(e))
                current_key = key_manager.switch_key()
                time.sleep(ERROR_DELAY)
                continue

        return all_pois

    def _get_poi_total_count(self, key_manager, type_code, grid_polygon, timeout):
        """获取POI总数和总页数"""
        current_key = key_manager.get_current_key()
        if not current_key:
            return -1

        params = {
            'key': current_key,
            'polygon': grid_polygon,
            'types': type_code,
            'offset': 20,
            'page': 1,
            'extensions': 'all'
        }

        max_attempts = len(key_manager.keys)
        for attempt in range(max_attempts):
            try:
                resp = requests.get('https://restapi.amap.com/v3/place/polygon', params=params, timeout=timeout)
                data = resp.json()

                if data.get('status') == '0':
                    info = data.get('info', '未知错误')
                    self.log(f"获取POI总数失败: {info} (key {current_key[:6]}...)", "WARNING")

                    # 标记Key状态并切换
                    key_manager.mark_key_status(current_key, info)
                    current_key = key_manager.switch_key()
                    params['key'] = current_key
                    time.sleep(KEY_SWITCH_DELAY)
                    continue

                total_count = int(data.get('count', 0))
                page_count = (total_count + 19) // 20  # 向上取整
                return total_count, page_count

            except Exception as e:
                self.log(f"获取POI总数异常: {e}", "ERROR")
                key_manager.switch_key()
                time.sleep(ERROR_DELAY)

        return -1, 0


# ==============================================================================
# GUI 主程序
# ==============================================================================

class POICrawlerApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("高德地图 POI 数据采集工具")
        self.geometry("800x800")

        # 变量初始化
        self.key_var = tk.StringVar(value='')
        self.type_var = tk.StringVar(value='')
        self.city_var = tk.StringVar(value='')
        self.grid_var = tk.DoubleVar(value=0.1)
        self.output_path_var = tk.StringVar(value=os.path.join(os.path.expanduser("~"), "Desktop", "AMAP_POI"))
        self.auto_rotate_var = tk.BooleanVar(value=True)
        self.settings_file_var = tk.StringVar(value=DEFAULT_SETTINGS_FILE)

        # 城市边界缓存（新增）
        self.city_boundary_cache = {}

        # 后台控制
        self.log_queue = queue.Queue()
        self.stop_event = threading.Event()
        self.is_running = False
        self.worker_thread = None
        self.key_manager = KeyManager([], auto_rotate=True)

        # 构建界面
        self.create_widgets()
        self.load_settings()
        self.process_log_queue()

    def create_widgets(self):
        # 主容器
        main_frame = ttk.Frame(self, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)

        # 顶部 Tab 区域
        nb = ttk.Notebook(main_frame)
        nb.pack(fill=tk.BOTH, expand=True, side=tk.TOP)

        # ============= Tab 1: 设置与运行 =============
        setting_tab = ttk.Frame(nb, padding=10)
        nb.add(setting_tab, text='任务设置')

        # --- 区块 1: 采集参数 ---
        param_frame = ttk.LabelFrame(setting_tab, text='1. 采集参数', padding=10)
        param_frame.pack(fill=tk.X, pady=5)

        # POI类型
        ttk.Label(param_frame, text="POI 类型编码:").grid(row=0, column=0, sticky='w')
        ttk.Entry(param_frame, textvariable=self.type_var).grid(row=0, column=1, columnspan=1, sticky='ew', padx=5,
                                                                pady=2)
        ttk.Label(param_frame, text="(例如: 010100, 多个用逗号分隔)", foreground="gray").grid(row=0, column=3, sticky='w')

        # 城市编码
        ttk.Label(param_frame, text="城市编码:").grid(row=1, column=0, sticky='w')
        ttk.Entry(param_frame, textvariable=self.city_var).grid(row=1, column=1, sticky='ew', padx=5, pady=2)
        ttk.Button(param_frame, text="清除", command=self.clear_city_input, width=8).grid(row=1, column=2, padx=2)
        ttk.Label(param_frame, text="(Adcode, 例如: 110000, 多个用逗号分隔)", foreground="gray").grid(row=1, column=3,
                                                                                             sticky='w')

        # 网格大小
        ttk.Label(param_frame, text="网格大小(度):").grid(row=2, column=0, sticky='w')
        ttk.Entry(param_frame, textvariable=self.grid_var, width=15).grid(row=2, column=1, sticky='w', padx=5, pady=2)
        ttk.Label(param_frame, text="(建议 0.02~0.1 之间)", foreground="gray").grid(row=2, column=3, sticky='w')

        param_frame.columnconfigure(1, weight=1)

        # --- 区块 2: 文件与配置 ---
        file_frame = ttk.LabelFrame(setting_tab, text='2. 文件与配置管理', padding=10)
        file_frame.pack(fill=tk.X, pady=5)

        # 输出目录
        ttk.Label(file_frame, text="输出数据目录:").grid(row=0, column=0, sticky='w')
        ttk.Entry(file_frame, textvariable=self.output_path_var).grid(row=0, column=1, sticky='ew', padx=5)
        bbox_out = ttk.Frame(file_frame)
        bbox_out.grid(row=0, column=2, sticky='w')
        ttk.Button(bbox_out, text='浏览', command=self.browse_output_folder, width=8).pack(side=tk.LEFT, padx=2)
        ttk.Button(bbox_out, text='打开目录', command=self.open_output_folder, width=8).pack(side=tk.LEFT, padx=2)

        # 配置文件路径
        ttk.Label(file_frame, text="配置文件路径:").grid(row=1, column=0, sticky='w')
        ttk.Entry(file_frame, textvariable=self.settings_file_var).grid(row=1, column=1, sticky='ew', padx=5)
        bbox_conf = ttk.Frame(file_frame)
        bbox_conf.grid(row=1, column=2, sticky='w')
        ttk.Button(bbox_conf, text='浏览', command=self.choose_settings_file, width=8).pack(side=tk.LEFT, padx=2)
        ttk.Button(bbox_conf, text='默认', command=self.reset_settings_path, width=8).pack(side=tk.LEFT, padx=2)

        # 配置文件操作按钮栏
        action_bar = ttk.Frame(file_frame)
        action_bar.grid(row=2, column=1, sticky='w', pady=5, padx=5)
        ttk.Button(action_bar, text='加载配置', command=self.load_settings, width=8).pack(side=tk.LEFT, padx=2)
        ttk.Button(action_bar, text='保存配置', command=self.save_settings, width=8).pack(side=tk.LEFT, padx=2)
        ttk.Button(action_bar, text='另存为', command=self.export_settings_as, width=8).pack(side=tk.LEFT, padx=2)

        # 新增：缓存管理按钮
        cache_bar = ttk.Frame(file_frame)
        cache_bar.grid(row=2, column=2, sticky='w', pady=5, padx=5)
        ttk.Button(cache_bar, text='查看缓存', command=self.view_city_cache, width=9).pack(side=tk.LEFT, padx=2)
        ttk.Button(cache_bar, text='清除缓存', command=self.clear_city_cache, width=9).pack(side=tk.LEFT, padx=2)

        file_frame.columnconfigure(1, weight=1)

        # --- 区块 3: 运行控制 ---
        ctrl_frame = ttk.Frame(setting_tab, padding=10)
        ctrl_frame.pack(fill=tk.X, pady=5)

        self.btn_start = ttk.Button(ctrl_frame, text='▶ 开始采集', command=self.start_task)
        self.btn_start.pack(side=tk.LEFT, padx=5, ipady=5, ipadx=10)

        self.btn_stop = ttk.Button(ctrl_frame, text='⏹ 停止任务', command=self.stop_task, state=tk.DISABLED)
        self.btn_stop.pack(side=tk.LEFT, padx=5, ipady=5, ipadx=10)

        ttk.Checkbutton(ctrl_frame, text='API Key 自动轮换', variable=self.auto_rotate_var).pack(side=tk.LEFT, padx=15)

        # 新增：Key使用限制提示
        ttk.Label(ctrl_frame, text=f"Key使用限制：{KEY_MAX_USAGE}次/冷却期({KEY_COOLDOWN_TIME}秒)", foreground="blue").pack(
            side=tk.RIGHT, padx=5)

        # ====== 日志区域 ======
        log_lf = ttk.LabelFrame(setting_tab, text='运行日志', padding=5)
        log_lf.pack(fill=tk.BOTH, expand=True, pady=(6, 10))

        self.txt_log = tk.Text(log_lf, state='disabled', height=12, font=('Consolas', 9))
        self.txt_log.pack(side='left', fill='both', expand=True)

        log_scr = ttk.Scrollbar(log_lf, orient='vertical', command=self.txt_log.yview)
        log_scr.pack(side='right', fill='y')
        self.txt_log.configure(yscrollcommand=log_scr.set)

        # 日志颜色配置
        self.txt_log.tag_config('INFO', foreground='black')
        self.txt_log.tag_config('SUCCESS', foreground='green')
        self.txt_log.tag_config('WARNING', foreground='#FF8C00')  # DarkOrange
        self.txt_log.tag_config('ERROR', foreground='red')

        # ============= Tab 2: API Key 管理 =============
        keys_frame = ttk.Frame(nb, padding=10)
        nb.add(keys_frame, text='API Key 管理')

        # 左侧列表
        left_pane = ttk.Frame(keys_frame)
        left_pane.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        lbl_keys = tk.Label(left_pane, text=f"Key 列表 (使用限制：{KEY_MAX_USAGE}次/冷却期)")
        lbl_keys.pack(anchor='w')

        self.lb_keys = tk.Listbox(left_pane, height=15)
        self.lb_keys.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scr = ttk.Scrollbar(left_pane, orient='vertical', command=self.lb_keys.yview)
        scr.pack(side=tk.RIGHT, fill=tk.Y)
        self.lb_keys.configure(yscrollcommand=scr.set)
        self.lb_keys.bind('<Double-Button-1>', self.on_key_double_click)

        # 右侧操作
        right_pane = ttk.Frame(keys_frame, padding=(10, 0))
        right_pane.pack(side=tk.RIGHT, fill=tk.BOTH, expand=False)

        ttk.Label(right_pane, text="输入 Key:").pack(anchor='w')
        self.key_entry = ttk.Entry(right_pane, textvariable=self.key_var, width=35)
        self.key_entry.pack(pady=5)

        ttk.Button(right_pane, text='添加 / 更新', command=self.add_key).pack(fill=tk.X, pady=2)
        ttk.Button(right_pane, text='删除选中', command=self.remove_selected_key).pack(fill=tk.X, pady=2)
        ttk.Separator(right_pane, orient='horizontal').pack(fill=tk.X, pady=8)
        ttk.Button(right_pane, text='从文件导入...', command=self.import_keys).pack(fill=tk.X, pady=2)
        ttk.Button(right_pane, text='测试选中 Key', command=self.test_selected_key).pack(fill=tk.X, pady=2)

        # 统计区
        stat_frame = ttk.LabelFrame(right_pane, text="当前会话使用统计", padding=5)
        stat_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        self.tree_stats = ttk.Treeview(stat_frame, columns=('key', 'count', 'status'), show='headings', height=8)
        self.tree_stats.heading('key', text='Key (前缀)')
        self.tree_stats.heading('count', text='使用次数')
        self.tree_stats.heading('status', text='当前状态')
        self.tree_stats.column('key', width=120)
        self.tree_stats.column('count', width=80)
        self.tree_stats.column('status', width=150)  # 加宽状态列
        self.tree_stats.pack(fill=tk.BOTH, expand=True)

        ttk.Button(stat_frame, text='刷新统计', command=self.refresh_key_stats).pack(fill=tk.X, pady=2)

        # ============= 底部：进度条和状态 =============
        prog_frame = ttk.Frame(main_frame)
        prog_frame.pack(fill=tk.X, pady=5)
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(prog_frame, variable=self.progress_var, maximum=100)
        self.progress_bar.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.lbl_status = ttk.Label(prog_frame, text='就绪', width=30, anchor='e')
        self.lbl_status.pack(side=tk.RIGHT, padx=5)

        # 全局快捷键
        self.bind_all('<Control-s>', lambda e: self.save_settings())

    # ================= 配置文件管理逻辑（新增城市缓存） =================
    def get_settings_file(self):
        path = self.settings_file_var.get().strip()
        return path if path else DEFAULT_SETTINGS_FILE

    def choose_settings_file(self):
        path = filedialog.asksaveasfilename(
            title="选择或创建配置文件",
            initialdir=os.path.dirname(self.get_settings_file()),
            defaultextension='.json',
            filetypes=[('JSON files', '*.json'), ('All files', '*.*')]
        )
        if path:
            self.settings_file_var.set(path)
            self.log_queue.put({'msg': f'已切换配置文件路径: {path}', 'level': 'INFO'})

    def reset_settings_path(self):
        self.settings_file_var.set(DEFAULT_SETTINGS_FILE)
        messagebox.showinfo('提示', '已恢复为默认配置文件路径')

    def export_settings_as(self):
        path = filedialog.asksaveasfilename(
            title="另存为配置",
            defaultextension='.json',
            filetypes=[('JSON files', '*.json')]
        )
        if not path:
            return
        self._save_to_file(path)
        messagebox.showinfo('成功', f'配置已导出至: {path}')

    def backup_settings(self):
        current_path = self.get_settings_file()
        if not os.path.exists(current_path):
            messagebox.showwarning('提示', '当前配置文件不存在，无法备份')
            return

        ts = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_path = f"{current_path}.{ts}.bak"
        try:
            shutil.copy2(current_path, backup_path)
            messagebox.showinfo('成功', f'备份已创建:\n{backup_path}')
        except Exception as e:
            messagebox.showerror('错误', f'备份失败: {e}')

    def save_settings(self):
        path = self.get_settings_file()
        self._save_to_file(path)
        messagebox.showinfo('保存成功', f'设置已保存到:\n{path}')

    def _save_to_file(self, filepath):
        data = {
            'keys': self.get_keys(),
            'type': self.type_var.get(),
            'cities': self.city_var.get(),
            'grid': self.grid_var.get(),
            'output': self.output_path_var.get(),
            'auto_rotate': self.auto_rotate_var.get(),
            'city_boundary_cache': self.city_boundary_cache  # 新增：保存城市边界缓存
        }
        try:
            os.makedirs(os.path.dirname(os.path.abspath(filepath)), exist_ok=True)
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            self.log_queue.put({'msg': f'保存配置失败: {e}', 'level': 'ERROR'})
            raise e

    def load_settings(self):
        path = self.get_settings_file()
        if not os.path.exists(path):
            self.log_queue.put({'msg': f'配置文件不存在，使用默认/空配置: {path}', 'level': 'WARNING'})
            return
        try:
            with open(path, 'r', encoding='utf-8') as f:
                data = json.load(f)

            self.set_keys(data.get('keys', []))
            self.type_var.set(data.get('type', ''))
            self.city_var.set(data.get('cities', ''))
            self.grid_var.set(data.get('grid', 0.1))
            self.output_path_var.set(data.get('output', self.output_path_var.get()))
            self.auto_rotate_var.set(data.get('auto_rotate', True))
            # 新增：加载城市边界缓存
            self.city_boundary_cache = data.get('city_boundary_cache', {})

            self.log_queue.put({'msg': f'成功加载配置: {path}', 'level': 'SUCCESS'})
            self.log_queue.put({'msg': f'加载城市边界缓存 {len(self.city_boundary_cache)} 条', 'level': 'INFO'})
        except Exception as e:
            self.log_queue.put({'msg': f'加载配置异常: {e}', 'level': 'ERROR'})
            messagebox.showerror("加载失败", f"无法读取配置文件:\n{e}")

    # ================= 城市缓存管理（新增） =================
    def view_city_cache(self):
        """查看城市边界缓存"""
        if not self.city_boundary_cache:
            messagebox.showinfo('提示', '暂无城市边界缓存数据')
            return

        # 创建缓存查看窗口
        cache_win = tk.Toplevel(self)
        cache_win.title('城市边界缓存')
        cache_win.geometry('600x400')

        # 创建表格
        tree = ttk.Treeview(cache_win, columns=('citycode', 'update_time', 'bbox'), show='headings')
        tree.heading('citycode', text='城市编码')
        tree.heading('update_time', text='缓存时间')
        tree.heading('bbox', text='边界范围')
        tree.column('citycode', width=100)
        tree.column('update_time', width=180)
        tree.column('bbox', width=300)

        # 填充数据
        for citycode, cache_data in self.city_boundary_cache.items():
            tree.insert('', 'end', values=(
                citycode,
                cache_data.get('update_time', '未知'),
                cache_data.get('bbox', '无')
            ))

        # 滚动条
        scrollbar = ttk.Scrollbar(cache_win, orient='vertical', command=tree.yview)
        tree.configure(yscrollcommand=scrollbar.set)

        tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')

        # 清除选中缓存按钮
        def delete_selected():
            selected = tree.selection()
            if not selected:
                return
            for item in selected:
                citycode = tree.item(item)['values'][0]
                if citycode in self.city_boundary_cache:
                    del self.city_boundary_cache[citycode]
                tree.delete(item)
            messagebox.showinfo('提示', '选中缓存已删除')

        ttk.Button(cache_win, text='删除选中缓存', command=delete_selected).pack(fill='x', pady=5)

    def clear_city_cache(self):
        """清除所有城市边界缓存"""
        if messagebox.askyesno('确认', '确定要清除所有城市边界缓存吗？'):
            self.city_boundary_cache.clear()
            self.log_queue.put({'msg': '已清除所有城市边界缓存', 'level': 'INFO'})
            messagebox.showinfo('提示', '所有城市边界缓存已清除')

    # ================= 其他辅助功能 =================
    def clear_city_input(self):
        self.city_var.set('')

    def browse_output_folder(self):
        path = filedialog.askdirectory()
        if path:
            self.output_path_var.set(path)

    def open_output_folder(self):
        path = self.output_path_var.get()
        if not os.path.exists(path):
            messagebox.showwarning('提示', '目录不存在，请先开始任务或手动创建')
            return

        try:
            system_name = platform.system()
            if system_name == 'Windows':
                os.startfile(path)
            elif system_name == 'Darwin':  # macOS
                subprocess.call(['open', path])
            else:  # Linux
                subprocess.call(['xdg-open', path])
        except Exception as e:
            messagebox.showerror('错误', f'无法打开目录: {e}')

    # ================= Key 管理（修改状态显示） =================
    def get_keys(self):
        return [self.lb_keys.get(i) for i in range(self.lb_keys.size())]

    def set_keys(self, keys):
        self.lb_keys.delete(0, tk.END)
        for k in keys:
            self.lb_keys.insert(tk.END, k)
        self.key_manager.set_keys(keys)
        self.refresh_key_stats()

    def add_key(self):
        k = self.key_var.get().strip()
        if not k:
            return

        sel = self.lb_keys.curselection()
        if sel:
            self.lb_keys.delete(sel[0])
            self.lb_keys.insert(sel[0], k)
        else:
            self.lb_keys.insert(tk.END, k)
        self.key_var.set('')
        self.key_manager.set_keys(self.get_keys())
        self.refresh_key_stats()

    def remove_selected_key(self):
        sel = self.lb_keys.curselection()
        if not sel:
            return
        for i in reversed(sel):
            removed_key = self.lb_keys.get(i)
            self.lb_keys.delete(i)
            # 从KeyManager中移除相关记录
            if removed_key in self.key_manager.usage_stats:
                del self.key_manager.usage_stats[removed_key]
            if removed_key in self.key_manager.temp_cooldown:
                del self.key_manager.temp_cooldown[removed_key]
        self.key_manager.set_keys(self.get_keys())
        self.refresh_key_stats()

    def import_keys(self):
        path = filedialog.askopenfilename(filetypes=[('Text files', '*.txt;*.csv'), ('All files', '*.*')])
        if not path:
            return
        try:
            with open(path, 'r', encoding='utf-8') as f:
                text = f.read()
            keys = [k.strip() for k in text.replace('\n', ',').split(',') if k.strip()]
            for k in keys:
                self.lb_keys.insert(tk.END, k)
            self.key_manager.set_keys(keys)
            self.refresh_key_stats()
            messagebox.showinfo('提示', f'导入了 {len(keys)} 个Key')
        except Exception as e:
            messagebox.showerror('错误', str(e))

    def on_key_double_click(self, event=None):
        sel = self.lb_keys.curselection()
        if sel:
            self.key_var.set(self.lb_keys.get(sel[0]))

    def test_selected_key(self):
        sel = self.lb_keys.curselection()
        if not sel:
            messagebox.showinfo('提示', '请先在列表选中一个 Key')
            return
        key = self.lb_keys.get(sel[0])
        threading.Thread(target=self._test_key_thread, args=(key,), daemon=True).start()

    def _test_key_thread(self, key):
        try:
            self.log_queue.put({'msg': f'正在测试Key {key[:6]}...', 'level': 'INFO'})
            r = requests.get('https://restapi.amap.com/v3/config/district',
                             params={'key': key, 'keywords': '北京'}, timeout=10)
            data = r.json()
            if data.get('status') == '1':
                self.log_queue.put({'msg': f'Key 测试通过: {key[:6]}...', 'level': 'SUCCESS'})
            else:
                info = data.get('info', '未知错误')
                self.log_queue.put({'msg': f'Key 测试失败: {key[:6]}... ({info})', 'level': 'WARNING'})
                # 标记Key进入冷却
                self.key_manager.mark_key_cooldown(key)
                self.refresh_key_stats()
        except Exception as e:
            self.log_queue.put({'msg': f'Key 测试出错: {e}', 'level': 'ERROR'})

    def refresh_key_stats(self):
        """刷新Key统计，显示状态（包含使用次数和冷却信息）"""
        self.tree_stats.delete(*self.tree_stats.get_children())
        for k, v in self.key_manager.get_usage().items():
            status = self.key_manager.get_key_status(k)
            self.tree_stats.insert('', 'end', values=(str(k)[:12] + '...', v, status))

    # ================= 日志与任务控制 =================
    def process_log_queue(self):
        try:
            while True:
                entry = self.log_queue.get_nowait()
                t, msg, lvl = entry.get('time', ''), entry.get('msg', ''), entry.get('level', 'INFO')
                self.txt_log.config(state='normal')
                if t:
                    self.txt_log.insert(tk.END, f'[{t}] ', 'INFO')
                self.txt_log.insert(tk.END, msg + '\n', lvl)
                self.txt_log.see(tk.END)
                self.txt_log.config(state='disabled')
        except queue.Empty:
            pass
        self.after(100, self.process_log_queue)

    def toggle_inputs(self, enable):
        state = tk.NORMAL if enable else tk.DISABLED
        self.btn_start.config(state=state)
        self.btn_stop.config(state=tk.DISABLED if enable else tk.NORMAL)
        # 锁定/解锁输入控件
        self.key_entry.config(state=state)
        self.type_var.set_readonly = lambda: state == tk.DISABLED
        self.city_var.set_readonly = lambda: state == tk.DISABLED
        self.grid_var.set_readonly = lambda: state == tk.DISABLED
        self.output_path_var.set_readonly = lambda: state == tk.DISABLED
        self.settings_file_var.set_readonly = lambda: state == tk.DISABLED

    def start_task(self):
        keys = self.get_keys()
        types = [t.strip() for t in self.type_var.get().split(',') if t.strip()]
        cities = [c.strip() for c in self.city_var.get().split(',') if c.strip()]

        if not keys:
            return messagebox.showerror('错误', '未配置 API Key')
        if not types:
            return messagebox.showerror('错误', '未填写 POI 类型')
        if not cities:
            return messagebox.showerror('错误', '未填写城市编码')

        out_dir = self.output_path_var.get()
        if not os.path.exists(out_dir):
            try:
                os.makedirs(out_dir)
            except Exception as e:
                return messagebox.showerror('错误', f'创建目录失败: {e}')

        self.is_running = True
        self.stop_event.clear()
        self.key_manager.set_keys(keys)
        self.key_manager.auto_rotate = self.auto_rotate_var.get()

        self.toggle_inputs(False)
        self.txt_log.config(state='normal')
        self.txt_log.delete(1.0, tk.END)
        self.txt_log.config(state='disabled')
        self.progress_var.set(0)
        self.lbl_status.config(text='正在初始化...', foreground='blue')

        self.worker_thread = threading.Thread(
            target=self.run_crawler,
            args=(keys, types, cities, self.grid_var.get(), out_dir),
            daemon=True
        )
        self.worker_thread.start()

    def stop_task(self):
        if self.is_running:
            if messagebox.askyesno('确认', '确定要停止任务吗？'):
                self.stop_event.set()
                self.lbl_status.config(text='正在停止...', foreground='red')

    def run_crawler(self, keys, type_codes, city_codes, grid_size, output_dir):
        # 传入城市边界缓存
        logic = AmapCrawlerLogic(self.log_queue, self.stop_event, self.city_boundary_cache)
        km = self.key_manager

        try:
            logic.log('正在计算任务规模...', 'INFO')
            # 预估任务量逻辑
            estimate_grids = 0
            for c in city_codes:
                if self.stop_event.is_set():
                    break
                poly, bbox = logic.get_city_coords(km, c)
                if bbox:
                    grids = logic.generate_grids(poly, bbox, grid_size)
                    estimate_grids += len(grids)
                time.sleep(REQUEST_INTERVAL)  # 城市之间增加延迟

            total_tasks = len(type_codes) * max(1, estimate_grids)
            task_done = 0

            logic.log(f'任务开始: {len(type_codes)}个类型 x {len(city_codes)}个城市', 'INFO')
            logic.log(f'预计总任务量: {total_tasks} 个网格', 'INFO')

            for t_code in type_codes:
                if self.stop_event.is_set():
                    break
                for c_code in city_codes:
                    if self.stop_event.is_set():
                        break

                    logic.log(f'\n===== 开始处理 POI类型: {t_code} - 城市编码: {c_code} =====', 'INFO')

                    poly, bbox = logic.get_city_coords(km, c_code)
                    if not bbox:
                        logic.log(f'城市 {c_code} 边界获取失败，跳过', 'ERROR')
                        time.sleep(ERROR_DELAY)
                        continue

                    grids = logic.generate_grids(poly, bbox, grid_size)
                    filename = f'POI_{t_code}_{c_code}.csv'
                    filepath = os.path.join(output_dir, filename)

                    logic.log(f'城市 {c_code} 生成 {len(grids)} 个有效网格', 'INFO')
                    time.sleep(REQUEST_INTERVAL)

                    for i, grid in enumerate(grids):
                        if self.stop_event.is_set():
                            break

                        logic.log(f'\n----- 处理网格 {i + 1}/{len(grids)} -----', 'INFO')
                        pois = logic.fetch_pois(km, t_code, grid)

                        # 更新进度
                        task_done += 1
                        prog = min(100, (task_done / total_tasks) * 100) if total_tasks else 0
                        self.progress_var.set(prog)
                        self.lbl_status.config(text=f'Processing: {t_code} - {c_code} ({i + 1}/{len(grids)})')

                        if pois:
                            df = pd.DataFrame(pois)
                            header = not os.path.exists(filepath)
                            df.to_csv(filepath, mode='a', header=header, index=False, encoding='utf-8-sig')
                            logic.log(f'  > 网格{i + 1} 采集到 {len(pois)} 条数据', 'SUCCESS')
                        else:
                            logic.log(f'  > 网格{i + 1} 无数据', 'INFO')

                        time.sleep(REQUEST_INTERVAL)  # 网格之间增加延迟

                    logic.log(f'===== POI类型: {t_code} - 城市编码: {c_code} 处理完成 =====', 'SUCCESS')
                    time.sleep(KEY_SWITCH_DELAY)  # 城市之间切换延迟

            # 任务结束后保存缓存
            self.city_boundary_cache = logic.city_boundary_cache
            self.save_settings()  # 自动保存配置（包含缓存）

            logic.log('\n任务结束', 'INFO')
            logic.log(f'总处理网格数: {task_done} 个', 'INFO')
            logic.log(f'各Key使用统计: {km.get_usage()}', 'INFO')

        except Exception as e:
            logic.log(f'任务发生未捕获异常: {e}', 'ERROR')
            traceback.print_exc()
        finally:
            self.is_running = False
            self.toggle_inputs(True)
            self.lbl_status.config(text='完成', foreground='green')
            self.refresh_key_stats()


if __name__ == '__main__':
    app = POICrawlerApp()
    app.mainloop()
